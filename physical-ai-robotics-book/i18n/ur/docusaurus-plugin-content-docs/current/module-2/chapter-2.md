

# ماڈیول 2: ڈیجیٹل ٹوئن (Gazebo & Unity)

## باب 2: سینسر سمولیشن اور ڈیٹا جنریشن

### ذیلی باب 1: روبوٹک سینسرز کی سمولیشن

#### سینسر سمولیشن کو سمجھنا

**تعارف**
یہ سیکشن مختلف روبوٹک سینسرز کی سمولیشن پر گہرائی سے روشنی ڈالتا ہے، جو AI ٹریننگ کے لیے مصنوعی ڈیٹا بنانے اور سینسر فیوژن الگورتھم کی توثیق کرنے میں ان کی اہمیت کو واضح کرتا ہے۔

**تفصیل**
مضبوط روبوٹک سسٹمز کو تیار کرنے کے لیے درست سینسر سمولیشن انتہائی اہم ہے۔ یہ ڈویلپرز کو مصنوعی ڈیٹا کی بڑی مقدار پیدا کرنے کی اجازت دیتا ہے، جو مشین لرننگ ماڈلز (مثلاً، آبجیکٹ کا پتہ لگانے، نیویگیشن، یا ہیرا پھیری کے لیے) کو تربیت دینے کے لیے قیمتی ہے بغیر مہنگے اور وقت طلب حقیقی دنیا کے ڈیٹا اکٹھا کرنے کے۔ Gazebo اور Unity جیسے سمولیٹرز عام روبوٹک سینسرز جیسے LiDAR (لائٹ ڈیٹیکشن اور رینجنگ)، ڈیپتھ کیمرے (مثلاً، RGB-D)، اور Inertial Measurement Units (IMUs) کا ماڈل بنانے کے لیے ٹولز فراہم کرتے ہیں۔ ان سینسرز کی سمولیشن کے ذریعے، ہم مختلف حالات (روشنی، رکاوٹیں، شور) کے تحت پرسیپشن الگورتھم کی جانچ کر سکتے ہیں اور سینسر فیوژن تکنیکوں کی کارکردگی کی توثیق کر سکتے ہیں جو متعدد ذرائع سے ڈیٹا کو یکجا کرتی ہیں۔

**کوڈ مثال**
```python
# تصوراتی مثال: سمولیٹڈ LiDAR ڈیٹا کو پڑھنا
# یہ سیوڈو-کوڈ ہے؛ اصل نفاذ سمولیٹر کے API پر منحصر ہے۔

class SimulatedLiDAR:
    def __init__(self, simulator_interface, sensor_id):
        self.interface = simulator_interface
        self.sensor_id = sensor_id

    def get_scan_data(self):
        """
        فزکس انجن سے سمولیٹڈ LiDAR اسکین بازیافت کرتا ہے۔
        واپس کرتا ہے: فاصلوں (رینجز) کی ایک فہرست یا ایک پوائنٹ کلاؤڈ۔
        """
        if not self.interface.is_sensor_active(self.sensor_id):
            print(f"Error: Sensor {self.sensor_id} is not active.")
            return []
        
        # حقیقی منظرنامے میں، یہ ایک سمولیٹر API کو کال کرے گا۔
        simulated_ranges = self.interface.read_sensor_data(self.sensor_id, 'LiDAR')
        print(f"Received {len(simulated_ranges)} LiDAR points.")
        return simulated_ranges

class SimulatorInterface:
    # سمولیٹر API کالز کے لیے پلیس ہولڈر
    def is_sensor_active(self, sensor_id):
        return True # اس مثال کے لیے فرض کریں کہ سینسر ہمیشہ فعال ہے

    def read_sensor_data(self, sensor_id, sensor_type):
        # کچھ ڈیٹا کی سمولیشن کریں
        if sensor_type == 'LiDAR':
            return [i * 0.1 for i in range(100)] # 100 پوائنٹس
        return []

# مثال استعمال:
# sim_interface = SimulatorInterface()
# lidar = SimulatedLiDAR(sim_interface, "front_lidar")
# scan = lidar.get_scan_data()
# print(f"First 5 LiDAR points: {scan[:5]}")
```

**تصویر/گراف کا پلیس ہولڈر**
![تصویر: ایک تصوراتی ڈایاگرام جو ایک سمولیٹڈ روبوٹ کو LiDAR سینسر کے ساتھ ایک ورچچول ماحول میں رکاوٹوں کا پتہ لگاتے ہوئے دکھاتا ہے، ایک پوائنٹ کلاؤڈ بناتے ہوئے۔](pathname:///static/img/placeholder_diagram_sensor_sim.png)

**کوئز**
روبوٹکس میں سینسر سمولیشن استعمال کرنے کا ایک اہم فائدہ کیا ہے؟
a) یہ کسی بھی حقیقی دنیا کے سینسر ڈیٹا کی ضرورت کو ختم کرتا ہے۔
b) یہ AI ماڈلز کو مصنوعی ڈیٹا کی بڑی مقدار کے ساتھ تربیت دینے کی اجازت دیتا ہے۔
c) یہ بنیادی طور پر مارکیٹنگ کے مواد کی تیاری کے لیے استعمال ہوتا ہے۔
d) یہ روبوٹ کے آن بورڈ پروسیسر پر کمپیوٹیشنل بوجھ کو کم کرتا ہے۔

**لغت**
-   **LiDAR**: لائٹ ڈیٹیکشن اور رینجنگ، ایک ریموٹ سینسنگ کا طریقہ جو فاصلوں کی پیمائش کے لیے پلسڈ لیزر کا استعمال کرتا ہے۔
-   **Depth Camera**: ایک کیمرہ جو ہر پکسل کے لیے نہ صرف رنگ بلکہ فاصلے کی معلومات بھی حاصل کرتا ہے۔
-   **IMU**: Inertial Measurement Unit، ایک ایسا آلہ جو ایک جسم کی زاویائی شرح، قوت، اور بعض اوقات واقفیت کی پیمائش کرتا ہے۔

**حوالہ جات**
-   [Gazebo سینسرز دستاویزات](http://gazebosim.org/tutorials?cat=sensors)
-   [Unity پرسیپشن پیکیج](https://github.com/Unity-Technologies/unity-perception)

**تاریخ**
فزکس انجنوں کی درستگی کے ساتھ سینسرز کو سمولیٹ کرنے کی صلاحیت میں نمایاں اضافہ ہوا ہے۔ ابتدائی سمولیشن بنیادی رینج فائنڈرز پر مرکوز تھے، جبکہ جدید سمولیٹرز پیچیدہ ملٹی موڈل سینسرز کو حقیقت پسندانہ شور ماڈلز کے ساتھ ماڈل بنا سکتے ہیں، جو جدید AI تحقیق کے لیے اہم ہے۔
